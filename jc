#!/usr/bin/env bash

set -euo pipefail

info() { printf '%s %s\n' "[INFO]" "$*" >&2; }
error() { printf '%s %s\n' "[ERROR]" "$*" >&2; }
die() { error "$@"; exit 1; }

command -v git &> /dev/null || die "git not found"
command -v curl &> /dev/null || die "curl not found"
command -v jq &> /dev/null || die "jq not found"
command -v python3 &> /dev/null || die "python3 not found"
python3 -m pip show tiktoken >/dev/null 2>&1 || die "tiktoken not installed"

load_config_file() {
  local file="$1"
  # shellcheck source=/dev/null
  test -f "${file}" && info "Loading config ${file}" && . "${file}"
}

load_config() {
  local config_file=".jcrc" config_loaded=

  local global_config="${HOME}/.jc/${config_file}"
  load_config_file "${global_config}" && config_loaded=1

  local repo_config
  repo_config="$(git -C "${CONTEXT_DIR}" rev-parse --show-toplevel)/${config_file}"
  load_config_file "${repo_config}" && config_loaded=1

  [[ -z "${config_loaded}" ]] && info "No config loaded"

  info "Applying environment variables"
  API_KEY="${JC_API_KEY:?api key is not set}"
  MODEL="${JC_MODEL:?model is not set}"
  GIT_DIFF_ARGS="${JC_GIT_DIFF_ARGS:-}"
  INSTRUCTIONS="${JC_INSTRUCTIONS:?instructions are not set}"
  MESSAGE_TEMPLATE="${JC_MESSAGE_TEMPLATE:?message templte is not set}"
  SAMPLE_INPUT="${JC_SAMPLE_INPUT:?sample input is not set}"
  SAMPLE_OUTPUT="${JC_SAMPLE_OUTPUT:?sample output is not set}"
  MAX_INPUT_TOKENS="${JC_MAX_INPUT_TOKENS:?max input tokens is not set}"
  MAX_OUTPUT_TOKENS="${JC_MAX_OUTPUT_TOKENS:?max output tokens is not set}"
  LOG_FILE="${JC_LOG_FILE:-}"

  return 0
}

log_curl() {
  [[ -z "${LOG_FILE}" ]] && return

  local request="$1"
  local response="$2"
  printf '{"time":"%s","request":%s,"response":%s}\n' \
    "$(date '+%Y-%m-%dT%H:%M:%S%z')" \
    "$(printf '%s' "${request}" | jq -Rs .)" \
    "$(printf '%s' "${response}" | jq -Rs .)" \
    >> "${LOG_FILE}"
}

print_stat() {
  local indexed_names excluded_names
  indexed_names="$(git -C "${CONTEXT_DIR}" diff --no-color --cached --name-only | sort)"
  excluded_names="$(git_diff_args | xargs -0 git -C "${CONTEXT_DIR}" diff --no-color --cached --name-only -- . | sort)"

  local excluded excluded_stat
  excluded="$(comm -23 <(echo "${indexed_names}") <(echo "${excluded_names}"))"
  excluded_stat="$(xargs git -C "${CONTEXT_DIR}" --no-pager diff --color --cached --stat=80 -- . <<< "${excluded}")"

  local indexed indexed_stat
  indexed="$(comm -12 <(echo "${indexed_names}") <(echo "${excluded_names}"))"
  indexed_stat="$(xargs git -C "${CONTEXT_DIR}" --no-pager diff --color --cached --stat=80 -- . <<< "${indexed}")"

  echo
  echo "Excluded files:"
  [[ -n "${excluded_stat}" ]] && echo "${excluded_stat}" || echo "No files"

  echo
  echo "Indexed files:"
  [[ -n "${indexed_stat}" ]] && echo "${indexed_stat}" || echo "No files"
}

git_diff_args() {
  printf '%s\n' "${GIT_DIFF_ARGS}" | awk 'NF && $1 !~ /^#/ { printf "%s\0", $0 }'
}

git_diff() {
  git_diff_args | xargs -0 git -C "${CONTEXT_DIR}" --no-pager diff --no-color --staged -- .
}

git_stat() {
  git_diff_args | xargs -0 git -C "${CONTEXT_DIR}" --no-pager diff --no-color --staged --numstat -- .
}

git_commit() {
  local commit="$1"
  git -C "${CONTEXT_DIR}" commit -m "${commit}"
}

git_edit_commit() {
  local commit="$1"
  git -C "${CONTEXT_DIR}" commit --edit -F <(echo "${commit}")
}

input_tokens() {
  local message="$1"
MODEL="${MODEL}" python3 <(cat <<'PY'
import sys, os, tiktoken
model = os.environ.get("MODEL", "")
enc = tiktoken.encoding_for_model(model)
text = sys.stdin.read()
print(len(enc.encode(text)))
PY
) <<< "${message} ${INSTRUCTIONS} ${SAMPLE_INPUT} ${SAMPLE_OUTPUT}"
}

ask_openai() {
  local message="$1"

  info "Sending request"
  local request
  request=$(jq -n \
    --arg model "${MODEL}" \
    --argjson maxOutputTokens "${MAX_OUTPUT_TOKENS}" \
    --arg instructions "${INSTRUCTIONS}" \
    --arg sampleInput "${SAMPLE_INPUT}" \
    --arg sampleOutput "${SAMPLE_OUTPUT}" \
    --arg message "${message}" '
{
  model: $model,
  max_output_tokens: $maxOutputTokens,
  input: [
    { role: "system",    content: [ { type: "input_text", text: $instructions } ] },
    { role: "user",      content: [ { type: "input_text", text: $sampleInput } ] },
    { role: "assistant", content: [ { type: "output_text", text: $sampleOutput } ] },
    { role: "user",      content: [ { type: "input_text", text: $message } ] }
  ]
}'
  )

  local response
  response=$(curl -sSL "https://api.openai.com/v1/responses" \
    -H "Authorization: Bearer ${API_KEY}" \
    -H "Content-Type: application/json" \
    -d "${request}"
  )

  log_curl "${request}" "${response}"

  err="$(jq -r 'if .error != null then .error.message else empty end' <<< "${response}")"
  [[ -n "${err}" ]] && die "${err}"

  jq -r '.output[] | select(.type=="message") | .content[0].text' <<< "${response}"
}

ask_ai() {
  local message="$1"
  case "${MODEL}" in
    gpt*) ask_openai "${message}" ;;
    *) die "no provider found" ;;
  esac
}

main() {
  print_stat

  local diff stat message tokens
  diff="$(git_diff)"
  stat="$(git_stat)"
  message="${MESSAGE_TEMPLATE//<stat>/$stat}"
  message="${message//<diff>/$diff}"
  tokens=$(input_tokens "${message}")
  [[ "${tokens}" -ge "${MAX_INPUT_TOKENS}" ]] && die "Number of input tokens (${tokens}) exceeds ${MAX_INPUT_TOKENS}"
  info "Required ${tokens} input tokens"

  local commit
  commit="$(ask_ai "${message}")"
  echo "Generated commit message:"
  echo
  echo "${commit}"
  echo

  local answer
  while :; do
    echo -n "Choose action: [c]onfirm, [e]dit, [n]ew, [a]bort: "

    stty -echo -icanon time 0 min 1
    IFS= read -r -n1 answer
    stty sane
    echo "${answer}"

    case "${answer}" in
      [cC]) git_commit "${commit}"; break ;;
      [eE]) git_edit_commit "${commit}"; break ;;
      [nN]) main "$@"; break ;;
      [aA]) exit 1 ;;
      *) echo "Invalid choice, try again." ;;
    esac
  done
}

# Setup the context before any run
CONTEXT_DIR="${JC_CONTEXT_DIR:-.}"
git -C "${CONTEXT_DIR}" rev-parse --git-dir > /dev/null 2>&1 || die "Git repo not found"
git -C "${CONTEXT_DIR}" diff-index --cached --quiet HEAD && die "Nothing to commit"

load_config

main "$@"
