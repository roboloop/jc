#!/usr/bin/env bash

set -euo pipefail

command -v git &> /dev/null || (echo "git not found" >&2 && exit 1)
command -v curl &> /dev/null || (echo "curl not found" >&2 && exit 1)
command -v jq &> /dev/null || (echo "jq not found" >&2 && exit 1)
command -v python3 &> /dev/null || (echo "python3 not found" >&2 && exit 1)
python3 -m pip show tiktoken >/dev/null 2>&1 || (echo "tiktoken not installed" >&2 && exit 1)

info() { printf '%s %s\n' "[INFO]" "$*" >&2; }
error() { printf '%s %s\n' "[ERROR]" "$*" >&2; }
die() { error "$@"; exit 1; }

load_config() {
  local config_file=".jcrc" config_loaded=

  local global_config
  global_config="${HOME}/.jc/${config_file}"
  if [[ -f "${global_config}" ]]; then
    info "Loading global config ${global_config}"
    . "${global_config}"
    config_loaded=t
  fi

  if git rev-parse --show-toplevel > /dev/null 2>&1; then
    local repo_dir local_config
    repo_dir="$(git rev-parse --show-toplevel)"
    local_config="${repo_dir}/${config_file}"
    if [[ -n "${repo_dir}" && -f "${local_config}" ]]; then
      info "Loading local config ${local_config}"
      . "${local_config}"
      config_loaded=t
    fi
  fi

  [[ -z "${config_loaded}" ]] && info "No config loaded"

  info "Applying environment variables"
  API_KEY="${JC_API_KEY:?api key is not set}"
  MODEL="${JC_MODEL:?model is not set}"
  GIT_DIFF_ARGS="${JC_GIT_DIFF_ARGS:-}"
  INSTRUCTIONS="${JC_INSTRUCTIONS:?instructions are not set}"
  SAMPLE_INPUT="${JC_SAMPLE_INPUT:?sample input is not set}"
  SAMPLE_OUTPUT="${JC_SAMPLE_OUTPUT:?sample output is not set}"
  MAX_INPUT_TOKENS="${JC_MAX_INPUT_TOKENS:?max input tokens is not set}"
  MAX_OUTPUT_TOKENS="${JC_MAX_OUTPUT_TOKENS:?max output tokens is not set}"
  LOG_FILE="${JC_LOG_FILE:-}"

  return 0
}

load_config

log_curl() {
  local request="$1"
  local response="$2"

  [[ -z "${LOG_FILE}" ]] && return

  printf '{"time":"%s","request":%s,"response":%s}\n' \
    "$(date '+%Y-%m-%dT%H:%M:%S%z')" \
    "$(printf '%s' "${request}" | jq -Rs .)" \
    "$(printf '%s' "${response}" | jq -Rs .)" \
    >> "${LOG_FILE}"
}

print_stat() {
  local dir indexed_names excluded_names
  dir="$(git rev-parse --show-toplevel)"
  indexed_names="$(eval "git -C \"${dir}\" diff --no-color --cached --name-only" | sort)"
  excluded_names="$(eval "git -C \"${dir}\" diff --no-color --cached --name-only ${GIT_DIFF_ARGS}" | sort)"

  local excluded excluded_stat
  excluded="$(comm -23 <(echo "${indexed_names}") <(echo "${excluded_names}"))"
  excluded_stat="$(xargs git -C "${dir}" --no-pager diff --color --cached --stat=80 -- <<< "${excluded}")"

  local indexed indexed_stat
  indexed="$(comm -12 <(echo "${indexed_names}") <(echo "${excluded_names}"))"
  indexed_stat="$(xargs git -C "${dir}" --no-pager diff --color --cached --stat=80 -- <<< "${indexed}")"

  echo
  echo "Excluded files:"
  [[ -n "${excluded_stat}" ]] && echo "${excluded_stat}" || echo "No files"

  echo
  echo "Indexed files:"
  [[ -n "${indexed_stat}" ]] && echo "${indexed_stat}" || echo "No files"
}

git_diff() {
  local dir
  dir="$(git rev-parse --show-toplevel)"
  if git -C "${dir}" diff-index --cached --quiet HEAD; then
    die "Nothing to commit"
  fi

  cmd="git -C \"${dir}\" diff --no-color --staged ${GIT_DIFF_ARGS}"
  eval "${cmd}"
}

git_stat() {
  local dir
  dir="$(git rev-parse --show-toplevel)"
  if git -C "${dir}" diff-index --cached --quiet HEAD; then
    die "Nothing to commit"
  fi

  cmd="git -C \"${dir}\" diff --no-color --staged --numstat --name-status ${GIT_DIFF_ARGS}"
  eval "${cmd}"
}

git_commit() {
  local message="$1"
  dir="$(git rev-parse --show-toplevel)"
  git -C "${dir}" commit -m "${message}"
}

git_edit_commit() {
  local message="$1"
  dir="$(git rev-parse --show-toplevel)"
  git -C "${dir}" commit --edit -F <(echo "${message}")
}

input_tokens() {
  local diff="$1"
MODEL="${MODEL}" python3 <(cat <<'PY'
import sys, os, tiktoken
model = os.environ.get("MODEL", "")
enc = tiktoken.encoding_for_model(model)
text = sys.stdin.read()
print(len(enc.encode(text)))
PY
) <<< "${diff} ${INSTRUCTIONS} ${SAMPLE_INPUT} ${SAMPLE_OUTPUT}"
}

ask_openai() {
  local diff="$1"
  local stat="$2"
  local formatted
  formatted="
  Here is the staged diff and diffstat. Generate 1 commit message.

  DIFFSTAT:
  ${stat}

  DIFF (context-free, minimal):
  ${diff}
"

  info "Sending request"
  local request
  request=$(jq -n \
    --arg model "${MODEL}" \
    --argjson maxOutputTokens "${MAX_OUTPUT_TOKENS}" \
    --arg instructions "${INSTRUCTIONS}" \
    --arg sampleInput "${SAMPLE_INPUT}" \
    --arg sampleOutput "${SAMPLE_OUTPUT}" \
    --arg diff "${formatted}" '
{
  model: $model,
  max_output_tokens: $maxOutputTokens,
  input: [
    { role: "system",    content: [ { type: "input_text", text: $instructions } ] },
    { role: "user",      content: [ { type: "input_text", text: $sampleInput } ] },
    { role: "assistant", content: [ { type: "output_text", text: $sampleOutput } ] },
    { role: "user",      content: [ { type: "input_text", text: $diff } ] }
  ]
}'
  )

  local response
  response=$(curl -sSL "https://api.openai.com/v1/responses" \
    -H "Authorization: Bearer ${API_KEY}" \
    -H "Content-Type: application/json" \
    -d "${request}"
  )

  log_curl "${request}" "${response}"

  err="$(jq -r 'if .error != null then .error.message else empty end' <<< "${response}")"
  [[ -n "${err}" ]] && die "${err}"

  jq -r '.output[] | select(.type=="message") | .content[0].text' <<< "${response}"
}

ask_ai() {
  local diff="$1"
  local stat="$2"
  case "${MODEL}" in
    gpt*) ask_openai "${diff}" "${stat}" ;;
    *) error "no provider found"
       return 1 ;;
  esac
}

main() {
  print_stat

  local diff stat tokens
  diff="$(git_diff)"
  stat="$(git_stat)"
  tokens=$(input_tokens "${diff}")
  [[ "${tokens}" -ge "${MAX_INPUT_TOKENS}" ]] && die "Number of input tokens (${tokens}) exceeds ${MAX_INPUT_TOKENS}"
  info "Required ${tokens} input tokens"

  local message
  message="$(ask_ai "${diff}" "${stat}")"
  echo "Generated message:"
  echo
  echo "${message}"
  echo

  local answer
  while :; do
    echo -n "Choose action: [c]onfirm, [e]dit, [n]ew, [a]bort: "

    stty -echo -icanon time 0 min 1
    IFS= read -r -n1 answer
    stty sane
    echo "${answer}"

    case "${answer}" in
      [cC]) git_commit "${message}"; break ;;
      [eE]) git_edit_commit "${message}"; break ;;
      [nN]) main "$@"; break ;;
      [aA]) exit 1 ;;
      *) echo "Invalid choice, try again." ;;
    esac
  done
}

JC_CONTEXT_DIR="${JC_CONTEXT_DIR:-}"
[[ -n "${JC_CONTEXT_DIR}" ]] && info "Running in context of ${JC_CONTEXT_DIR}" && cd "${JC_CONTEXT_DIR}"

main "$@"

